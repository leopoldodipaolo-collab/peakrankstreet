{# --- CORREZIONE: Estende il template di base, non la homepage --- #}
{% extends "base.html" %}

{% block title %}Tracciamento Live{% endblock %}

{% block content %}
<meta name="csrf-token" content="{{ csrf_token() }}">

<!-- Splash Screen -->
<div id="welcomeSplash" class="splash-screen vh-100 d-flex align-items-center justify-content-center">
  <div class="splash-content text-center">
    <div class="spinner-grow text-primary mb-3" style="width: 3rem; height: 3rem;" role="status">
      <span class="visually-hidden">Caricamento...</span>
    </div>
    <h3 class="text-white">Preparazione Tracciamento</h3>
    <p class="text-white-50">Ottimizzazione segnale GPS...</p>
    <div class="progress mt-3 mx-auto w-75" style="height: 8px;">
      <div class="progress-bar progress-bar-striped progress-bar-animated bg-info" style="width: 100%"></div>
    </div>
  </div>
</div>

<div class="container-fluid my-3 pt-4">
  <div class="row justify-content-center">
    <div class="col-12">

      <!-- Header con Controlli -->
      <div class="text-center mb-4 position-relative d-flex justify-content-center align-items-center">
        <div class="position-absolute top-0 end-0 me-2">
          <button class="btn btn-sm btn-outline-secondary me-2 rounded-circle" id="darkModeToggle" aria-label="Toggle Dark Mode">
            <span class="light-icon">üåô</span>
            <span class="dark-icon d-none">‚òÄÔ∏è</span>
          </button>
          <button class="btn btn-sm btn-outline-primary rounded-circle" data-bs-toggle="modal" data-bs-target="#settingsModal" aria-label="Impostazioni">‚öôÔ∏è</button>
        </div>
        <h1 class="display-6 fw-bold text-primary mb-0">üèÉ Traccia la tua Attivit√†</h1>
      </div>

      <!-- Indicatori di Stato -->
      <div class="status-indicators d-flex justify-content-center flex-wrap gap-2 mb-3 text-center">
        <span class="badge rounded-pill bg-secondary" id="statusBadge">üü¢ Pronto</span>
        <span class="badge rounded-pill bg-danger" id="gpsStatus">üì° GPS: Non Disponibile</span>
        <span class="badge rounded-pill bg-info" id="accuracyStatus">üéØ Precisione: --</span>
        <span class="badge rounded-pill bg-warning text-dark" id="batteryStatus">üîã Batteria: --</span>
      </div>

      <!-- Selezione Percorso -->
      <div class="card mb-3 rounded-4 shadow-sm tracking-card">
        <div class="card-header bg-white">
          <h5 class="mb-0 fs-6"><i class="bi bi-signpost-split-fill me-2 text-primary"></i> Percorso (Opzionale)</h5>
        </div>
        <div class="card-body p-2">
          <select class="form-select form-select-sm rounded-3" id="routeSelect" aria-label="Seleziona Percorso">
            <option value="">üéØ Modalit√† Libera</option>
            {% for route in routes %}
            <option value="{{ route.id }}" data-distance="{{ route.distance or 0 }}">
              üìç {{ route.name }} {% if route.distance %}({{ "%.1f"|format(route.distance) }} km){% endif %}
            </option>
            {% endfor %}
          </select>
        </div>
      </div>

      <!-- Pannello Tracking -->
      <div class="card shadow-lg rounded-4 tracking-card vh-75 d-flex flex-column">
        <div class="card-header bg-primary text-white rounded-top-4">
          <h5 class="mb-0 fs-5 py-1"><i class="bi bi-broadcast-pin me-2"></i> Tracciamento Live</h5>
        </div>
        <div class="card-body text-center p-3 flex-grow-1 d-flex flex-column justify-content-center align-items-center">

          <button id="btnStart" class="btn btn-success btn-lg mb-3 rounded-pill w-75 shadow-sm fs-5">
            ‚ñ∂Ô∏è INIZIA
          </button>

          <div id="autoStartMessage" class="alert alert-info rounded-3 w-100 mb-3 p-2 d-none" role="alert">
            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
            <strong>Avvio GPS...</strong>
          </div>

          <div id="liveStats" class="w-100 d-none flex-column">
            <div class="row mb-3 g-2">
              <div class="col-6"><div class="stat-box-mobile pulse-animation"><div class="stat-value text-primary" id="timer">00:00:00</div><div class="stat-label">TEMPO</div></div></div>
              <div class="col-6"><div class="stat-box-mobile"><div class="stat-value text-success" id="distance">0.00</div><div class="stat-label">DIST (KM)</div></div></div>
            </div>
            <div class="row mb-3 g-2">
              <div class="col-6"><div class="stat-box-mobile"><div class="stat-value text-warning" id="pace">0:00</div><div class="stat-label">RITMO (MIN/KM)</div></div></div>
              <div class="col-6"><div class="stat-box-mobile"><div class="stat-value text-info" id="speed">0.0</div><div class="stat-label">VEL (KM/H)</div></div></div>
            </div>

            <div class="row mb-2 g-2" id="advancedStats" style="display:none;">
              <div class="col-4"><div class="stat-box-sm"><div class="stat-value-sm text-danger" id="calories">0</div><div class="stat-label-sm">CAL</div></div></div>
              <div class="col-4"><div class="stat-box-sm"><div class="stat-value-sm text-purple" id="elevation">+0m</div><div class="stat-label-sm">SALITA</div></div></div>
              <div class="col-4"><div class="stat-box-sm"><div class="stat-value-sm text-orange" id="efficiency">--</div><div class="stat-label-sm">EFF</div></div></div>
            </div>

            <div class="splits-container mb-3 w-100" id="splitsContainer" style="display:none;">
              <h6 class="text-muted mb-2 fs-7">üéØ ULTIMO SPLIT</h6>
              <div class="split-card d-flex justify-content-between align-items-center p-2">
                <span id="lastSplitKm" class="fs-7">1km</span>
                <span id="lastSplitTime" class="fs-7">00:00:00</span>
                <span id="lastSplitPace" class="fs-7">0:00/km</span>
              </div>
            </div>

            <div class="progress mb-3 w-100 d-none" id="routeProgress" style="height: 20px;">
              <div class="progress-bar progress-bar-striped progress-bar-animated bg-success" style="width:0%">
                <span class="progress-text fs-8">0%</span>
              </div>
            </div>

            <div id="miniMap" class="mb-3 rounded-3 border shadow-sm w-100 flex-grow-1" style="min-height: 250px;"></div>
          </div>

          <div class="tracking-controls mt-auto pt-3 d-flex justify-content-center w-100">
            <button id="btnPause" class="btn btn-warning btn-lg rounded-pill me-2 flex-grow-1" style="display:none;">‚è∏Ô∏è PAUSA</button>
            <button id="btnStop" class="btn btn-danger btn-lg rounded-pill flex-grow-1" style="display:none;">‚èπÔ∏è FERMA</button>
          </div>

          <div id="statusMessage" class="mt-3 w-100"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal Istruzioni GPS -->
<div class="modal fade" id="gpsInstructionsModal" tabindex="-1" aria-labelledby="gpsInstructionsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content rounded-4 shadow">
      <div class="modal-header bg-warning rounded-top-4">
        <h5 class="modal-title" id="gpsInstructionsModalLabel">‚ö†Ô∏è Abilita il GPS</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Chiudi"></button>
      </div>
      <div class="modal-body">
        <p>Per tracciare la tua attivit√†, abilita la posizione GPS nel tuo browser.</p>
        <div class="accordion" id="gpsAccordion">
          <div class="accordion-item">
            <h6 class="accordion-header">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#chromeHelp" aria-expanded="false" aria-controls="chromeHelp">
                üåê Chrome
              </button>
            </h6>
            <div id="chromeHelp" class="accordion-collapse collapse" data-bs-parent="#gpsAccordion">
              <div class="accordion-body small">
                1. Clicca sull'icona üîí a sinistra della barra URL.<br>
                2. Trova "Posizione" e seleziona "Consenti".<br>
                3. Ricarica la pagina.
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <h6 class="accordion-header">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#firefoxHelp" aria-expanded="false" aria-controls="firefoxHelp">
                ü¶ä Firefox
              </button>
            </h6>
            <div id="firefoxHelp" class="accordion-collapse collapse" data-bs-parent="#gpsAccordion">
              <div class="accordion-body small">
                1. Clicca sull'icona a sinistra della barra URL.<br>
                2. Seleziona "Consenti condivisione posizione".<br>
                3. Ricarica la pagina.
              </div>
            </div>
          </div>
          <div class="accordion-item">
            <h6 class="accordion-header">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#safariHelp" aria-expanded="false" aria-controls="safariHelp">
                üçé Safari
              </button>
            </h6>
            <div id="safariHelp" class="accordion-collapse collapse" data-bs-parent="#gpsAccordion">
              <div class="accordion-body small">
                1. Vai su Preferenze ‚Üí Sito Web ‚Üí Posizione.<br>
                2. Imposta "Consenti" per questo sito.<br>
                3. Ricarica la pagina.
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary rounded-pill w-100" data-bs-dismiss="modal">Ho capito!</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal Riepilogo Attivit√† -->
<div class="modal fade" id="activitySummaryModal" tabindex="-1" aria-labelledby="activitySummaryModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content rounded-4 shadow">
      <div class="modal-header bg-success text-white rounded-top-4">
        <h5 class="modal-title" id="activitySummaryModalLabel">üìä Riepilogo Attivit√†</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Chiudi"></button>
      </div>
      <div class="modal-body">
        <div class="row text-center mb-3">
          <div class="col-6 mb-2">
            <div class="stat-box-summary"><div class="stat-value text-primary" id="summaryDuration">00:00:00</div><div class="stat-label">DURATA</div></div>
          </div>
          <div class="col-6 mb-2">
            <div class="stat-box-summary"><div class="stat-value text-success" id="summaryDistance">0.00</div><div class="stat-label">DIST (KM)</div></div>
          </div>
          <div class="col-6">
            <div class="stat-box-summary"><div class="stat-value text-info" id="summarySpeed">0.0</div><div class="stat-label">VEL MEDIA</div></div>
          </div>
          <div class="col-6">
            <div class="stat-box-summary"><div class="stat-value text-warning" id="summaryPace">0:00</div><div class="stat-label">RITMO MEDIO</div></div>
          </div>
        </div>
        <div class="advanced-summary mt-3 p-3 bg-light rounded">
          <h6 class="text-center mb-3">üìà Metriche Avanzate</h6>
          <div class="row text-center">
            <div class="col-4"><div class="stat-value-sm text-danger" id="summaryCalories">0</div><small class="text-muted">Calorie</small></div>
            <div class="col-4"><div class="stat-value-sm text-purple" id="summaryElevation">+0m</div><small class="text-muted">Dislivello</small></div>
            <div class="col-4"><div class="stat-value-sm text-orange" id="summaryEfficiency">--</div><small class="text-muted">Efficienza</small></div>
          </div>
        </div>
        <div class="mt-3 p-3 bg-light rounded">
          <small class="text-muted">üí° L'attivit√† verr√† salvata nel tuo profilo per analisi dettagliate.</small>
        </div>
      </div>
      <div class="modal-footer flex-column gap-2">
        <button type="button" class="btn btn-secondary rounded-pill w-100" data-bs-dismiss="modal">Annulla</button>
        <button type="button" class="btn btn-success rounded-pill w-100" id="confirmSaveBtn">üíæ Salva Attivit√†</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal Settings -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="settingsModalLabel">‚öôÔ∏è Impostazioni</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Chiudi"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="themeColor" class="form-label">üé® Tema Colori</label>
          <select class="form-select" id="themeColor" aria-label="Tema Colori">
            <option value="default">Blu Classico</option>
            <option value="green">Verde Sport</option>
            <option value="purple">Viola Energia</option>
            <option value="orange">Arancio</option>
          </select>
        </div>
        <div class="mb-3">
          <label for="unitSystem" class="form-label">üìè Unit√† di Misura</label>
          <select class="form-select" id="unitSystem" aria-label="Unit√† di Misura">
            <option value="metric">Metrico (km, min/km)</option>
            <option value="imperial">Imperiale (mi, min/mi)</option>
          </select>
        </div>
        <div class="mb-3">
          <label for="userWeight" class="form-label">‚öñÔ∏è Il tuo Peso (kg)</label>
          <input type="number" class="form-control" id="userWeight" min="30" max="150" value="70" aria-label="Peso Utente">
          <small class="text-muted">Usato per calcolare le calorie bruciate.</small>
        </div>
        <div class="form-check form-switch mb-3">
          <input class="form-check-input" type="checkbox" id="audioToggle" role="switch">
          <label class="form-check-label" for="audioToggle">üîä Feedback Audio</label>
        </div>
        <div class="form-check form-switch mb-3">
          <input class="form-check-input" type="checkbox" id="notificationsToggle" role="switch">
          <label class="form-check-label" for="notificationsToggle">üîî Notifiche Browser</label>
        </div>
        <div class="form-check form-switch mb-3">
          <input class="form-check-input" type="checkbox" id="privacyMode" role="switch">
          <label class="form-check-label" for="privacyMode">üïµÔ∏è Modalit√† Privacy (Approssima posizione)</label>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Chiudi</button>
        <button type="button" class="btn btn-primary" id="saveSettingsBtn">Salva Impostazioni</button>
      </div>
    </div>
  </div>
</div>

<style>
/* Stili Base Ottimizzati Mobile */
body { padding-bottom: 60px; /* Spazio per eventuale navbar fisso */ }
.splash-screen { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
.splash-content { animation: fadeInUp 0.8s ease; }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

.stat-box-mobile {
  padding: 10px 8px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e0e0e0;
  display: flex; flex-direction: column; justify-content: center; height: 100px;
}
.stat-box-mobile:hover { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.08); }
.stat-value { font-size: 1.5em; font-weight: bold; margin-bottom: 3px; transition: color 0.3s ease; }
.stat-label { font-size: 0.7em; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px; }

.stat-box-sm { padding: 8px 5px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; }
.stat-value-sm { font-size: 1.1em; font-weight: bold; margin-bottom: 2px; }
.stat-label-sm { font-size: 0.65em; color: #6c757d; text-transform: uppercase; }

.stat-box-summary { padding: 15px 10px; background: #f8f9fa; border-radius: 12px; border: 2px solid #e9ecef; margin: 5px;}
.stat-value.text-primary, .stat-value.text-success, .stat-value.text-warning, .stat-value.text-info,
.stat-value-sm.text-danger, .stat-value-sm.text-purple, .stat-value-sm.text-orange { font-size: 1.8em; }
.stat-label { font-size: 0.75em; }

.tracking-card { border-left: 4px solid #28a745; transition: all 0.3s ease; }
.tracking-active { border-left-color: #28a745 !important; background: linear-gradient(90deg, rgba(40, 167, 69, 0.05) 0%, transparent 100%); }
.tracking-paused { border-left-color: #ffc107 !important; background: linear-gradient(90deg, rgba(255, 193, 7, 0.05) 0%, transparent 100%); }

.tracking-controls .btn { min-width: 120px; margin: 5px; transition: all 0.2s ease;}
#btnStart { min-width: 180px; font-size: 1.1rem; }

#gpsIndicator { width: 12px; height: 12px; border-radius: 50%; background: #dc3545; margin-left: 5px; transition: background 0.3s ease; display: inline-block; }
.gps-active { background: #28a745 !important; box-shadow: 0 0 8px rgba(40, 167, 69, 0.5); }

.pulse-animation { animation: pulse 2s infinite; }
@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

.progress-bar { transition: width 0.5s ease-in-out; background-size: 200% 100% !important; animation: gradientShift 2s ease infinite; }
@keyframes gradientShift { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.progress-text { font-weight: bold; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); }

.value-change { animation: highlight 1s ease; }
@keyframes highlight { 0% { background-color: rgba(255, 255, 0, 0.3); } 100% { background-color: transparent; } }

.splits-container { background: #f8f9fa; border-radius: 10px; padding: 10px; }
.split-card { background: white; border-radius: 8px; border-left: 3px solid #28a745; }

/* Notifiche */
.split-notification { animation: slideInRight 0.5s ease; }
@keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

/* Dark Mode */
.dark-mode { background-color: #1a1a1a !important; color: #e0e0e0 !important; }
.dark-mode .card, .dark-mode .stat-box-mobile, .dark-mode .stat-box-sm, .dark-mode .stat-box-summary,
.dark-mode .modal-content, .dark-mode .dropdown-menu, .dark-mode .bg-light { background-color: #2d2d2d !important; border-color: #404040 !important; }
.dark-mode .text-muted { color: #bbb !important; }
.dark-mode .alert { background-color: #3a3a3a !important; border-color: #4a4a4a !important; }
.dark-mode .btn-outline-secondary, .dark-mode .btn-outline-primary { border-color: #555 !important; color: #e0e0e0 !important; }
.dark-mode .btn-outline-secondary:hover, .dark-mode .btn-outline-primary:hover { background-color: #444 !important; }
.dark-mode .modal-header { border-bottom-color: #404040 !important; }
.dark-mode .modal-footer { border-top-color: #404040 !important; }

/* Temi Colori */
.theme-green .btn-primary, .theme-green .bg-primary { background-color: #198754 !important; border-color: #198754 !important; }
.theme-purple .btn-primary, .theme-purple .bg-primary { background-color: #6f42c1 !important; border-color: #6f42c1 !important; }
.theme-orange .btn-primary, .theme-orange .bg-primary { background-color: #fd7e14 !important; border-color: #fd7e14 !important; }

/* Colori Specifici */
.text-purple { color: #6f42c1 !important; }
.text-orange { color: #fd7e14 !important; }

/* Sovrapposizione Tour */
.tour-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; }
.tour-step { position: relative; z-index: 10001; width: 90%; }
.tour-content { background: #fff; border-radius: 15px; padding: 20px; }
.dark-mode .tour-content { background: #333; }
.tour-title { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: var(--bs-primary); }
.tour-text { font-size: 0.9em; color: #555; }
.dark-mode .tour-text { color: #ccc; }
.tour-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 20px; }
.tour-counter { font-size: 0.8em; color: #888; }
.tour-buttons .btn { margin-left: 10px; }

/* Scrollbar Personalizzata */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 10px; }
::-webkit-scrollbar-thumb { background: rgba(193,193,193,0.5); border-radius: 10px; }
::-webkit-scrollbar-thumb:hover { background: rgba(168,168,168,0.7); }

/* Responsive Adjustments */
@media (max-width: 576px) {
  .splash-content h3 { font-size: 1.5rem; }
  .splash-content p { font-size: 0.9rem; }
  .display-6 { font-size: 1.8rem !important; }
  .stat-value { font-size: 1.3em; }
  .stat-label { font-size: 0.65em; }
  #btnStart { font-size: 1rem; padding: 12px 20px; }
  .tracking-controls .btn { padding: 12px 15px; font-size: 0.9rem; min-width: 100px; }
  .modal-dialog { margin: 0.5rem; }
  .tour-step { width: 95%; }
}
</style>

{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
// =============================================
// AUDIO FEEDBACK SYSTEM
// =============================================
class AudioFeedback {
  constructor() {
    this.enabled = true;
    this.init();
  }
  
  init() {
    this.enabled = !window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (!this.enabled) return;
    
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.log('Web Audio API non supportata:', e);
      this.enabled = false;
    }
  }
  
  playBeep(frequency = 440, duration = 200, volume = 0.3) {
    if (!this.enabled || !this.audioContext) return;
    try {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      oscillator.connect(gainNode); gainNode.connect(this.audioContext.destination);
      oscillator.frequency.value = frequency; oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration / 1000);
      oscillator.start(this.audioContext.currentTime); oscillator.stop(this.audioContext.currentTime + duration / 1000);
    } catch (e) { console.log('Errore riproduzione audio:', e); }
  }
  
  playStart() { this.playBeep(523, 200); }    // Do
  playPause() { this.playBeep(392, 200); }    // Sol
  playStop() { this.playBeep(330, 300); }     // Mi
  playKm() { this.playBeep(659, 150); }       // Mi alto
  playAlert() { this.playBeep(784, 400, 0.5); } // Sol alto
}

// =============================================
// ACTIVITY TRACKER MIGLIORATO PER MOBILE
// =============================================
class ActivityTracker {
  constructor() {
    this.isTracking = false; this.isPaused = false;
    this.startTime = null; this.positions = []; this.watchId = null;
    this.distance = 0; this.miniMap = null; this.polyline = null;
    this.timerInterval = null; this.autoSaveInterval = null;
    this.errorCount = 0; this.maxErrors = 5; this.currentPositionMarker = null;
    this.splits = []; this.splitDistance = 1; this.lastSplitAt = 0;
    this.audioFeedback = new AudioFeedback();
    this.privacyMode = false; this.userWeight = 70;
    this.route_id = null; this.duration = 0; this.avgSpeed = 0; this.avgPace = '0:00';

    this.loadUserSettings();
    this.setupSplits();
    this.setupBrowserNotifications();
    this.checkInitialGPSStatus();
  }

  loadUserSettings() {
    const settings = JSON.parse(localStorage.getItem('appSettings') || '{}');
    this.userWeight = settings.userWeight || 70;
    this.privacyMode = settings.privacyMode || false;
    this.audioFeedback.enabled = settings.audioEnabled !== false;
    document.body.classList.toggle('dark-mode', settings.darkModeEnabled === true); // Usa === true per coerenza
    // Applica tema colore se presente
    document.body.className = document.body.className.replace(/\btheme-\w+/g, '');
    document.body.classList.add(`theme-${settings.themeColor || 'default'}`);
  }

  checkInitialGPSStatus() {
    if (!navigator.geolocation) {
      this.showStatus("Il tuo browser non supporta la geolocalizzazione.", "danger");
      this.updateGPSIndicator(false); // Assicurati che l'indicatore sia corretto
      document.getElementById('gpsStatus').textContent = "üì° GPS: Non Supportato";
      document.getElementById('gpsStatus').className = "badge rounded-pill bg-dark";
      return false;
    }
    return true;
  }

  async requestLocationPermission() {
     try {
       const position = await new Promise((resolve, reject) => {
         navigator.geolocation.getCurrentPosition(resolve, reject, {
           enableHighAccuracy: true,
           timeout: 5000, // Timeout breve per la richiesta iniziale
           maximumAge: 0
         });
       });
       this.updateGPSIndicator(true);
       document.getElementById('gpsStatus').textContent = "üì° GPS: Connesso";
       document.getElementById('gpsStatus').className = "badge rounded-pill bg-success";
       return true;
     } catch (error) {
       console.error('Errore richiesta GPS:', error);
       // Mostra il modal solo se il permesso √® stato negato o la posizione non √® disponibile
       if (error.code === error.PERMISSION_DENIED || error.code === error.POSITION_UNAVAILABLE) {
         const modal = new bootstrap.Modal(document.getElementById('gpsInstructionsModal'));
         modal.show();
       }
       this.updateGPSIndicator(false); // Indica che non √® connesso
       document.getElementById('gpsStatus').textContent = "üì° GPS: Richiesto";
       document.getElementById('gpsStatus').className = "badge rounded-pill bg-warning text-dark";
       return false;
     }
  }

  async startTracking() {
    if (!this.checkInitialGPSStatus()) return;
    // Richiede il permesso e verifica se √® stato concesso
    if (!await this.requestLocationPermission()) {
        this.showStatus("Il GPS √® necessario per avviare il tracciamento.", "warning");
        return; // Ferma se il permesso non √® stato ottenuto
    }

    document.getElementById('autoStartMessage').classList.remove('d-none');
    this.updateStatusBadge('tracking'); // <<< CORRETTO: Questa funzione ora √® definita

    try {
      this.initMiniMap();
      this.isTracking = true; this.isPaused = false;
      this.startTime = new Date(); this.positions = []; this.distance = 0;
      this.errorCount = 0; this.splits = []; this.lastSplitAt = 0;

      this.updateTimer();
      // Intervallo per aggiornamenti periodici
      this.timerInterval = setInterval(() => {
        this.updateTimer(); this.checkForSplits(); this.updateAdvancedMetrics();
      }, 1000);
      this.startAutoSave(); // Avvia auto-save
      
      // Inizia a ricevere aggiornamenti di posizione
      this.watchId = navigator.geolocation.watchPosition(
        pos => this.handlePosition(pos),
        err => this.handleError(err),
        { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000, distanceFilter: 5 } // Opzioni per watchPosition
      );

      // Aggiorna UI per stato attivo
      document.getElementById('btnStart').classList.add('d-none');
      document.getElementById('btnPause').classList.remove('d-none');
      document.getElementById('btnStop').classList.remove('d-none');
      document.getElementById('liveStats').classList.remove('d-none');
      document.getElementById('liveStats').style.display = 'flex'; // Forza display flex
      document.getElementById('splitsContainer').style.display = 'block';
      document.getElementById('miniMap').style.display = 'block';
      document.querySelector('.tracking-card').classList.add('tracking-active');
      document.querySelector('.tracking-card').classList.remove('tracking-paused');

      document.getElementById('autoStartMessage').classList.add('d-none'); // Nasconde messaggio di avvio
      this.showStatus("‚úÖ Tracciamento attivo!", "success");
      this.audioFeedback.playStart();
      this.showBrowserNotification("Tracciamento Avviato", "L'attivit√† √® in corso...");

    } catch (error) {
      console.error('Errore avvio tracking:', error);
      this.showStatus("‚ùå Errore nell'avvio del tracciamento.", "danger");
      this.resetUI(); // Resetta UI in caso di errore grave
    }
  }

  initMiniMap() {
    // Se la mappa √® gi√† inizializzata, pulisci i layer precedenti
    if (this.miniMap) { 
        this.polyline.setLatLngs([]); // Resetta la linea del percorso
        if (this.currentPositionMarker) this.miniMap.removeLayer(this.currentPositionMarker); // Rimuovi marker precedente
        return;
    }
    
    // Coordinate iniziali (es. centro Italia) o usa ultima posizione nota se disponibile
    const initialLat = 42.35; const initialLng = 13.395;
    this.miniMap = L.map('miniMap', { 
      zoomControl: true, // Mostra controlli zoom
      touchZoom: true,   // Abilita zoom touch
      dragging: true     // Abilita trascinamento
    }).setView([initialLat, initialLng], 15); // Vista iniziale

    // Aggiungi tile layer (mappa base)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' 
    }).addTo(this.miniMap);

    // Aggiungi la polilinea per il percorso
    this.polyline = L.polyline([], { color: 'red', weight: 4, opacity: 0.7, lineJoin: 'round' }).addTo(this.miniMap);
    // Aggiungi il marker per la posizione corrente
    this.currentPositionMarker = L.circleMarker([initialLat, initialLng], { 
      radius: 8, fillColor: "#ff0000", color: "#000", weight: 2, opacity: 1, fillOpacity: 0.8 
    }).addTo(this.miniMap);
    // Aggiungi scala alla mappa
    this.miniMap.addControl(L.control.scale());
  }

  handlePosition(pos) {
    // Filtra posizioni con accuratezza molto bassa, a meno che non siano le prime
    if (pos.coords.accuracy > 50 && this.positions.length > 5) { 
      this.showStatus(`‚ö†Ô∏è Bassa precisione GPS (${Math.round(pos.coords.accuracy)}m)`, "warning", 3000);
      return; // Ignora questa posizione se non √® abbastanza accurata
    }

    // Crea un oggetto posizione standardizzato
    const newPos = {
      lat: pos.coords.latitude, lng: pos.coords.longitude,
      timestamp: new Date(), speed: pos.coords.speed || 0, // Velocit√† (m/s), 0 se non disponibile
      accuracy: pos.coords.accuracy, // Accuratezza in metri
      altitude: pos.coords.altitude || null // Altitudine in metri, null se non disponibile
    };

    // Applica modalit√† privacy se attiva (approssima le coordinate)
    const processedPos = this.privacyMode ? this.getApproximatePosition(newPos) : newPos;

    this.updateAccuracyIndicator(processedPos.accuracy); // Aggiorna l'indicatore di accuratezza

    // Calcola distanza solo se abbiamo posizioni precedenti e la distanza √® ragionevole
    if (this.positions.length > 0) {
      const last = this.positions[this.positions.length - 1];
      const d = this.calculateDistance(last.lat, last.lng, processedPos.lat, processedPos.lng); // Distanza in km
      // Filtra punti troppo vicini (es. < 1 metro) o salti enormi (es. > 500 metri)
      if (d < 0.001 || d > 0.5) return; 
      this.distance += d; // Aggiunge la distanza percorsa
    }

    this.positions.push(processedPos); // Aggiunge la nuova posizione all'array
    this.updateDisplay(); // Aggiorna statistiche live
    this.updateMap(processedPos); // Aggiorna mappa
    this.updateRouteProgress(); // Aggiorna progresso percorso (se selezionato)
    this.errorCount = 0; // Resetta contatore errori GPS se la posizione √® valida
  }

  // Calcola la distanza in km tra due punti GPS usando la formula di Haversine
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raggio della Terra in km
    const dLat = (lat2 - lat1) * Math.PI / 180; // Differenza lat in radianti
    const dLon = (lon2 - lon1) * Math.PI / 180; // Differenza lon in radianti
    const a = Math.sin(dLat/2) ** 2 + 
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
              Math.sin(dLon/2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); // Distanza in km
  }

  // Aggiorna le statistiche visualizzate (tempo, distanza, ritmo, velocit√†)
  updateDisplay() {
    const timerEl = document.getElementById('timer');
    const distanceEl = document.getElementById('distance');
    const paceEl = document.getElementById('pace');
    const speedEl = document.getElementById('speed');

    // Aggiorna tempo (HH:MM:SS)
    timerEl.textContent = this.formatTime(new Date() - this.startTime, true); 
    // Aggiorna distanza
    distanceEl.textContent = this.distance.toFixed(2);
    // Aggiunge classe per animazione cambio valore
    [distanceEl, timerEl].forEach(el => el.classList.add('value-change')); 

    // Calcola e aggiorna ritmo e velocit√† solo se ci sono dati validi
    const elapsedHours = (new Date() - this.startTime) / 3600000;
    if (elapsedHours > 0 && this.distance > 0) {
      const avgPaceMinutes = (elapsedHours * 60) / this.distance; // Ritmo medio in min/km
      paceEl.textContent = this.formatPace(avgPaceMinutes);
      speedEl.textContent = (this.distance / elapsedHours).toFixed(1); // Velocit√† media in km/h
      [paceEl, speedEl].forEach(el => el.classList.add('value-change'));
    } else { // Valori di default se non ci sono dati
      paceEl.textContent = '0:00'; speedEl.textContent = '0.0';
    }
    // Rimuove classe animazione dopo 1 secondo
    setTimeout(() => {
      [distanceEl, timerEl, paceEl, speedEl].forEach(el => el.classList.remove('value-change'));
    }, 1000);
  }

  // Aggiorna le metriche avanzate (calorie, salita, efficienza)
  updateAdvancedMetrics() {
    const metrics = this.calculateMetrics();
    document.getElementById('calories').textContent = metrics.calories;
    document.getElementById('elevation').textContent = `+${metrics.elevation.ascent}m`;
    document.getElementById('efficiency').textContent = metrics.efficiency;
    // Anima i valori che cambiano
    ['calories', 'elevation', 'efficiency'].forEach(id => document.getElementById(id).classList.add('value-change'));
    setTimeout(() => {
      ['calories', 'elevation', 'efficiency'].forEach(id => document.getElementById(id).classList.remove('value-change'));
    }, 1000);
  }
  
  // Calcola metriche avanzate basate sui dati attuali
  calculateMetrics() {
    const hours = Math.max(1, (new Date() - this.startTime) / 3600000); // Evita divisione per zero
    const met = this.getMETValue(); // Valore MET basato sulla velocit√†
    const calories = Math.round(met * this.userWeight * hours); // Calcolo calorie
    const elevation = this.calculateElevationFromPositions(); // Calcolo salita/discesa
    const efficiency = this.calculateEfficiencyScore(); // Calcolo efficienza
    return { calories, elevation, efficiency };
  }

  // Stima il valore MET (Metabolic Equivalent of Task) basato sulla velocit√† media
  getMETValue() {
    const avgSpeed = this.distance / ((new Date() - this.startTime) / 3600000); // km/h
    if (avgSpeed < 5) return 4.0;    // Camminata lenta/moderata
    if (avgSpeed < 8) return 7.0;    // Corsa leggera
    if (avgSpeed < 12) return 10.0;  // Corsa media
    return 12.0;                    // Corsa intensa
  }

  // Calcola il dislivello totale (salita) basato sulle variazioni di altitudine
  calculateElevationFromPositions() {
    if (this.positions.length < 2) return { ascent: 0, descent: 0 }; // Non ci sono abbastanza dati
    let ascent = 0; let descent = 0;
    for (let i = 1; i < this.positions.length; i++) {
      const alt1 = this.positions[i-1].altitude || 0; // Usa 0 se altitudine non disponibile
      const alt2 = this.positions[i].altitude || 0;
      const diff = alt2 - alt1;
      // Considera solo se altitudine √® disponibile per entrambi i punti e la variazione √® significativa
      if (alt1 > 0 && alt2 > 0) { 
        if (diff > 2) ascent += diff;       // Salita
        else if (diff < -2) descent += Math.abs(diff); // Discesa
      }
    }
    return { ascent: Math.round(ascent), descent: Math.round(descent) };
  }

  // Calcola un punteggio di efficienza (valore arbitrario)
  calculateEfficiencyScore() {
    if (this.distance < 0.1) return '--'; // Non calcolabile con poca distanza
    const pace = ((new Date() - this.startTime) / 60000) / this.distance; // Ritmo in min/km
    const elevationRate = this.calculateElevationFromPositions().ascent / this.distance; // Salita in m/km
    // Formula arbitraria: penalizza ritmo lento, premia salita (adattabile)
    let efficiency = 100 - (pace * 8) + (elevationRate * 3); 
    efficiency = Math.max(0, Math.min(100, efficiency)); // Limita tra 0 e 100
    // Assegna un grado basato sul punteggio
    if (efficiency >= 80) return 'A+'; if (efficiency >= 60) return 'A';
    if (efficiency >= 40) return 'B'; if (efficiency >= 20) return 'C';
    return 'D';
  }

  // Aggiorna il timer visualizzato
  updateTimer() {
    if (!this.startTime) return; // Non fare nulla se il tempo non √® iniziato
    const timerEl = document.getElementById('timer');
    timerEl.textContent = this.formatTime(new Date() - this.startTime, true); // Formato HH:MM:SS
  }

  // Aggiorna la mappa con la nuova posizione e il percorso
  updateMap(pos) {
    if (!this.miniMap) return; // Non fare nulla se la mappa non √® inizializzata
    const ll = [pos.lat, pos.lng]; // LatLng per Leaflet
    this.polyline.addLatLng(ll); // Aggiunge punto alla polilinea del percorso
    this.currentPositionMarker.setLatLng(ll); // Aggiorna posizione marker
    
    // Centra la mappa sulla nuova posizione solo per le prime posizioni o se l'utente non sta interagendo
    if (this.positions.length < 5 || this.miniMap.isMoving()) { 
      this.miniMap.setView(ll);
    }
  }

  // Aggiorna l'indicatore visivo del segnale GPS e il badge di stato
  updateGPSIndicator(active) {
    const el = document.getElementById('gpsIndicator'); // Potrebbe non esistere se non usato nell'HTML
    const statusEl = document.getElementById('gpsStatus');
    if (active) {
      el?.classList.add('gps-active'); // Usa optional chaining per sicurezza
      statusEl.textContent = "üì° GPS: Attivo";
      statusEl.className = "badge rounded-pill bg-success";
    } else {
      el?.classList.remove('gps-active');
      statusEl.textContent = "üì° GPS: Inattivo";
      statusEl.className = "badge rounded-pill bg-danger";
    }
  }

  // Aggiorna l'indicatore di accuratezza GPS
  updateAccuracyIndicator(accuracy) {
    const accuracyEl = document.getElementById('accuracyStatus');
    accuracyEl.textContent = `üéØ ${Math.round(accuracy)}m`;
    // Cambia colore del badge in base all'accuratezza
    accuracyEl.className = `badge rounded-pill ${
      accuracy < 15 ? 'bg-success' : accuracy < 40 ? 'bg-warning text-dark' : 'bg-danger'
    }`;
  }

  // Aggiorna lo stato della batteria visualizzato
  updateBatteryStatus() {
    if ('getBattery' in navigator) { // Verifica supporto API Batteria
      navigator.getBattery().then(battery => {
        const batteryEl = document.getElementById('batteryStatus');
        const level = Math.round(battery.level * 100); // Percentuale batteria
        batteryEl.textContent = `üîã ${level}%`;
        // Cambia colore del badge in base al livello
        batteryEl.className = `badge rounded-pill ${
          level > 50 ? 'bg-success' : level > 20 ? 'bg-warning text-dark' : 'bg-danger'
        }`;
      }).catch(() => { /* Ignora se l'API non √® disponibile */ });
    }
  }

  // Aggiorna la barra di progresso del percorso selezionato
  updateRouteProgress() {
    const sel = document.getElementById('routeSelect');
    const selectedOption = sel.options[sel.selectedIndex];
    // Ottieni la distanza del percorso dall'attributo data-distance
    const routeDistance = parseFloat(selectedOption?.getAttribute('data-distance')) || 0;
    
    if (routeDistance > 0) {
      const progress = Math.min(100, (this.distance / routeDistance) * 100); // Calcola percentuale
      const progressBar = document.getElementById('routeProgress').querySelector('.progress-bar');
      progressBar.style.width = `${progress}%`; // Imposta larghezza barra
      progressBar.querySelector('.progress-text').textContent = `${progress.toFixed(0)}%`; // Aggiorna testo
      document.getElementById('routeProgress').style.display = 'block'; // Mostra barra
    } else {
      document.getElementById('routeProgress').style.display = 'none'; // Nasconde barra se nessun percorso
    }
  }

  // --- FUNZIONI PER GLI SPLIT (es. km completati) ---
  setupSplits() { 
    this.splits = []; // Resetta array split
    this.splitDistance = 1; // Distanza tra split (es. 1 km)
    this.lastSplitAt = 0; // Ultimo km per cui √® stato registrato uno split
  }

  // Controlla se √® stato raggiunto un nuovo intero km per registrare uno split
  checkForSplits() {
    if (!this.isTracking || this.isPaused) return; // Non fare nulla se non attivo o in pausa
    const kmCompleted = Math.floor(this.distance); // Km interi percorsi
    // Se il numero di km interi √® aumentato rispetto all'ultimo split registrato
    if (kmCompleted > this.lastSplitAt) {
      for (let km = this.lastSplitAt + 1; km <= kmCompleted; km++) {
        this.recordSplit(km); // Registra split per ogni nuovo km
      }
      this.lastSplitAt = kmCompleted; // Aggiorna l'ultimo km registrato
    }
  }

  // Registra uno split per un dato km
  recordSplit(km) {
    const splitTime = new Date() - this.startTime; // Tempo trascorso dall'inizio
    const splitPace = this.calculatePaceForKm(km); // Calcola ritmo per questo km
    const split = { kilometer: km, time: splitTime, pace: splitPace, timestamp: new Date() };
    this.splits.push(split); // Aggiunge lo split all'array
    this.showSplitNotification(split); // Mostra notifica split
    this.audioFeedback.playKm(); // Riproduce suono per split
  }

  // Calcola il ritmo medio per un determinato km (basato sul tempo impiegato per quel km)
  calculatePaceForKm(km) {
    if (km === 1) return this.formatPace((new Date() - this.startTime) / 60000); // Tempo totale per il primo km
    // Trova l'ultimo split registrato
    const split = this.splits.find(s => s.kilometer === km - 1); 
    if (!split) return '0:00'; // Se non trovato, ritorna 0
    // Tempo impiegato per percorrere l'ultimo km (differenza tra tempo attuale e tempo dello split precedente)
    const timeForKm = (new Date() - this.startTime - split.time) / 60000; // in minuti
    return this.formatPace(timeForKm); // Formatta il tempo in min:sec
  }

  // --- FUNZIONI PER NOTIFICHE BROWSER ---
  setupBrowserNotifications() { 
    if (!("Notification" in window)) { // Verifica supporto API notifiche
      console.log("Browser non supporta notifiche");
      return;
    }
  }
  
  // Mostra una notifica push nel browser
  showBrowserNotification(title, body) {
    const settings = JSON.parse(localStorage.getItem('appSettings') || '{}');
    // Richiede permesso se non concesso e se abilitate nelle impostazioni
    if (Notification.permission === "granted" && settings.notificationsEnabled) {
      new Notification(title, { 
        body: body, 
        icon: '/static/favicon.ico', // Assicurati che il percorso sia corretto
        badge: '/static/favicon.ico' 
      });
    } else if (Notification.permission !== "denied") {
      // Se non concesso ma non negato, prova a richiederlo
      Notification.requestPermission();
    }
  }

  // --- FUNZIONI PER AUTO-SALVATAGGIO E PRIVACY ---
  startAutoSave() {
    // Intervallo per salvare backup ogni 60 secondi
    this.autoSaveInterval = setInterval(async () => {
      if (this.isTracking && !this.isPaused && this.positions.length > 0) {
        await this.backupActivity(); // Esegue il backup
      }
    }, 60000); 
  }

  // Salva i dati correnti dell'attivit√† in localStorage come backup
  async backupActivity() {
    const backupData = {
      positions: this.positions, // Array di posizioni GPS
      distance: this.distance,   // Distanza totale
      startTime: this.startTime, // Data/ora inizio attivit√†
      duration: new Date() - this.startTime, // Durata in ms
      splits: this.splits        // Array degli split
    };
    localStorage.setItem('activityBackup', JSON.stringify(backupData));
  }

  // Approssima le coordinate per la modalit√† privacy
  getApproximatePosition(position, radiusKm = 0.3) {
    // Calcola uno scostamento casuale entro un raggio specificato (in km)
    const offsetLat = (Math.random() - 0.5) * (radiusKm / 110.574); // ~110.574 km per grado di latitudine
    const offsetLng = (Math.random() - 0.5) * (radiusKm / (111.320 * Math.cos(position.lat * Math.PI / 180))); // ~111.320 km per grado di longitudine (varia con lat)
    return { 
      ...position, // Copia tutte le propriet√† originali
      lat: position.lat + offsetLat, // Applica offset latitudine
      lng: position.lng + offsetLng  // Applica offset longitudine
    };
  }

  // --- CONTROLLI PRINCIPALI (PAUSA, FERMA) ---
  pauseTracking() {
    this.isPaused = !this.isPaused; // Inverte lo stato di pausa
    if (this.isPaused) { // Se ora √® in pausa
      if (this.watchId) navigator.geolocation.clearWatch(this.watchId); // Interrompe il monitoraggio GPS
      this.watchId = null;
      document.getElementById('btnPause').innerHTML = '‚ñ∂Ô∏è RIPRENDI'; // Cambia testo pulsante
      // Aggiorna stili per indicare pausa
      document.querySelector('.tracking-card').classList.remove('tracking-active');
      document.querySelector('.tracking-card').classList.add('tracking-paused');
      this.showStatus("‚è∏Ô∏è Tracciamento in pausa.", "warning");
      this.updateGPSIndicator(false); // Indica GPS non attivo
      this.updateStatusBadge('paused'); // Aggiorna badge di stato
      this.audioFeedback.playPause(); // Suono di pausa
    } else { // Se ora sta riprendendo
      // Riavvia il monitoraggio GPS con le stesse opzioni
      this.watchId = navigator.geolocation.watchPosition(
        pos => this.handlePosition(pos),
        err => this.handleError(err),
        { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000, distanceFilter: 5 }
      );
      document.getElementById('btnPause').innerHTML = '‚è∏Ô∏è PAUSA'; // Cambia testo pulsante
      // Aggiorna stili per indicare tracciamento attivo
      document.querySelector('.tracking-card').classList.remove('tracking-paused');
      document.querySelector('.tracking-card').classList.add('tracking-active');
      this.showStatus("‚úÖ Tracciamento ripreso!", "success");
      this.audioFeedback.playStart(); // Suono di ripresa
    }
  }

  // Gestisce errori del GPS
  handleError(err) {
    this.errorCount++; // Incrementa contatore errori
    // Se gli errori superano il limite massimo, interrompi il tracciamento
    if (this.errorCount >= this.maxErrors) {
      this.showStatus("‚ùå Segnale GPS perso. Tracciamento sospeso.", "danger");
      this.stopTracking(); 
      return;
    }
    // Messaggio di errore basato sul codice
    let msg = "Errore GPS";
    if (err.code === err.PERMISSION_DENIED) {
      msg = "Permesso GPS negato."; 
      // Mostra istruzioni se il permesso √® negato
      const modal = new bootstrap.Modal(document.getElementById('gpsInstructionsModal')); 
      modal.show();
    } else if (err.code === err.POSITION_UNAVAILABLE) msg = "Posizione non disponibile.";
    else if (err.code === err.TIMEOUT) msg = "Timeout GPS, riprovo...";
    
    this.showStatus(`‚ö†Ô∏è ${msg} (${this.errorCount}/${this.maxErrors})`, "danger", 4000); // Mostra messaggio di errore
    this.updateGPSIndicator(false); // Indica GPS non attivo
  }

  // Ferma il tracciamento, calcola metriche finali e mostra modal di riepilogo
  async stopTracking() {
    // Pulisce timer e watchPosition
    if (this.watchId) navigator.geolocation.clearWatch(this.watchId); this.watchId = null;
    if (this.timerInterval) clearInterval(this.timerInterval);
    if (this.autoSaveInterval) clearInterval(this.autoSaveInterval);
    
    this.isTracking = false; // Imposta stato non attivo
    this.updateGPSIndicator(false); // Disattiva indicatore GPS
    this.updateStatusBadge('ready'); // Aggiorna badge a "Pronto"

    // Calcola valori finali
    const sel = document.getElementById('routeSelect');
    this.route_id = sel.value || null; // ID percorso selezionato
    this.duration = Math.max(1, Math.round((new Date() - this.startTime) / 1000)); // Durata in secondi (minimo 1)
    this.distance = Math.max(0.01, this.distance); // Distanza minima 0.01 km

    const hours = this.duration / 3600; // Durata in ore
    this.avgSpeed = (this.distance / hours).toFixed(1); // Velocit√† media km/h
    const paceMinutes = (hours * 60) / this.distance; // Ritmo medio min/km
    this.avgPace = this.formatPace(paceMinutes); // Formatta ritmo

    // Calcola metriche avanzate finali
    const finalMetrics = this.calculateMetrics();
    
    // Aggiorna il modal di riepilogo attivit√†
    document.getElementById('summaryDuration').textContent = this.formatTime(this.duration * 1000, true); // Formato HH:MM:SS
    document.getElementById('summaryDistance').textContent = this.distance.toFixed(2);
    document.getElementById('summarySpeed').textContent = this.avgSpeed;
    document.getElementById('summaryPace').textContent = this.avgPace;
    document.getElementById('summaryCalories').textContent = finalMetrics.calories;
    document.getElementById('summaryElevation').textContent = `+${finalMetrics.elevation.ascent}m`;
    document.getElementById('summaryEfficiency').textContent = finalMetrics.efficiency;

    // Mostra il modal di riepilogo
    const modal = new bootstrap.Modal(document.getElementById('activitySummaryModal'));
    modal.show();

    // Gestisce il click sul pulsante di conferma salvataggio
    document.getElementById('confirmSaveBtn').onclick = async () => {
      modal.hide(); // Chiude il modal
      // Prepara i dati da inviare al backend
      const data = {
        route_id: this.route_id, duration: this.duration, distance: this.distance,
        positions: this.positions, start_time: this.startTime.toISOString(),
        avg_speed: this.avgSpeed, avg_pace: this.avgPace,
        calories: finalMetrics.calories, elevation: finalMetrics.elevation.ascent,
        splits: this.splits
      };
      await this.saveActivity(data); // Chiama la funzione per salvare l'attivit√†
    };
    
    this.audioFeedback.playStop(); // Suono di stop
    localStorage.removeItem('activityBackup'); // Rimuove il backup
    this.resetUI(); // Resetta l'interfaccia utente allo stato iniziale
  }

  // Invia i dati dell'attivit√† al backend per il salvataggio
  async saveActivity(data) {
    const statusEl = document.getElementById('statusMessage');
    statusEl.innerHTML = '<div class="alert alert-info w-100">üíæ Salvataggio in corso...</div>'; // Messaggio di salvataggio
    try {
      // Ottiene il token CSRF dal meta tag
      const csrfMeta = document.querySelector('meta[name="csrf-token"]');
      const csrfToken = csrfMeta ? csrfMeta.content : null;
      // Header per la richiesta
      const headers = { 'Content-Type': 'application/json' };
      if (csrfToken) headers['X-CSRFToken'] = csrfToken;

      // Effettua la richiesta POST all'API
      const res = await fetch('/api/save-live-activity', {
        method: 'POST', headers: headers, body: JSON.stringify(data), credentials: 'same-origin'
      });

      // Gestisce errori di risposta HTTP
      if (!res.ok) { 
        const text = await res.text(); 
        throw new Error(`Errore server ${res.status}: ${text}`); 
      }
      const result = await res.json(); // Parsa la risposta JSON
      
      // Gestisce successo o fallimento basato sulla risposta del server
      if (result.success) {
        statusEl.innerHTML = `<div class="alert alert-success w-100">${result.message}</div>`;
        // Reindirizza alla pagina delle attivit√† dopo un breve ritardo
        setTimeout(() => window.location.href = "{{ url_for('main.all_activities') }}", 2000);
      } else { 
        throw new Error(result.error || "Errore sconosciuto dal server"); 
      }
    } catch (error) {
      console.error("Save activity failed:", error);
      statusEl.innerHTML = `<div class="alert alert-danger w-100">‚ùå Errore salvataggio: ${error.message}</div>`;
    }
  }

  // Mostra un messaggio di stato temporaneo nell'area apposita
  showStatus(msg, type, timeout = 5000) {
    const el = document.getElementById('statusMessage');
    // Crea l'elemento alert con messaggio e pulsante di chiusura
    el.innerHTML = `<div class="alert alert-${type} alert-dismissible fade show w-100" role="alert">${msg}<button type="button" class="btn-close" data-bs-dismiss="alert"></button></div>`;
    // Rimuove l'alert automaticamente dopo il timeout, se specificato
    if (timeout && timeout > 0) {
      setTimeout(() => { 
        // Controlla se il messaggio √® ancora quello visualizzato prima di rimuoverlo
        if (el.innerHTML.includes(msg)) el.innerHTML = ''; 
      }, timeout);
    }
  }

  // Funzioni Helper di Formattazione Tempo e Ritmo
  formatTime(ms, includeHours = false) {
    const seconds = Math.floor(ms / 1000); // Tempo in secondi
    const h = Math.floor(seconds / 3600); // Ore
    const m = Math.floor((seconds % 3600) / 60); // Minuti
    const s = seconds % 60; // Secondi
    // Formatta con zero iniziali se necessario
    if (includeHours) return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; // HH:MM:SS
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; // MM:SS
  }
  
  formatPace(minutes) {
    const m = Math.floor(minutes); // Minuti interi
    const s = Math.floor((minutes - m) * 60); // Secondi
    return `${m}:${s.toString().padStart(2, '0')}`; // Formatta min:sec
  }

  // Mostra notifica per lo split appena completato e aggiorna l'interfaccia
  showSplitNotification(split) {
    // Aggiorna l'area dello split nell'interfaccia
    document.getElementById('lastSplitKm').textContent = `${split.kilometer}km`;
    document.getElementById('lastSplitTime').textContent = this.formatTime(split.time, true); // Formato HH:MM:SS
    document.getElementById('lastSplitPace').textContent = `${split.pace}/km`;
    
    // Crea e mostra una notifica temporanea nell'area statusMessage
    const notificationEl = document.createElement('div');
    notificationEl.className = 'alert alert-info alert-dismissible split-notification w-100';
    notificationEl.innerHTML = `
      <strong>üéâ ${split.kilometer}km!</strong> Ritmo: ${split.pace}/km
      <button type="button" class="btn-close btn-close-white float-end" onclick="this.parentElement.remove()"></button>
    `;
    const statusMessage = document.getElementById('statusMessage');
    statusMessage.prepend(notificationEl); // Aggiunge la notifica all'inizio della lista
    // Rimuove la notifica dopo 7 secondi
    setTimeout(() => { if (notificationEl.parentElement) notificationEl.remove(); }, 7000);
    // Mostra anche una notifica push del browser
    this.showBrowserNotification(`üéØ ${split.kilometer}km Completato!`, `Ritmo: ${split.pace}/km`);
  }

  // Resetta tutti gli elementi dell'interfaccia utente allo stato iniziale (come se l'app fosse appena caricata)
  resetUI() { 
    document.getElementById('btnStart').classList.remove('d-none');
    document.getElementById('btnPause').classList.add('d-none');
    document.getElementById('btnStop').classList.add('d-none');
    document.getElementById('liveStats').classList.add('d-none');
    document.getElementById('autoStartMessage').classList.add('d-none');
    document.getElementById('splitsContainer').style.display = 'none';
    document.getElementById('routeProgress').style.display = 'none';
    // Rimuove classi di stato dalla card principale
    document.querySelector('.tracking-card').classList.remove('tracking-active', 'tracking-paused');
    // Resetta valori delle statistiche
    document.getElementById('timer').textContent = '00:00:00';
    document.getElementById('distance').textContent = '0.00';
    document.getElementById('pace').textContent = '0:00';
    document.getElementById('speed').textContent = '0.0';
    document.getElementById('calories').textContent = '0';
    document.getElementById('elevation').textContent = '+0m';
    document.getElementById('efficiency').textContent = '--';
    // Resetta notifiche split
    document.getElementById('lastSplitKm').textContent = '1km';
    document.getElementById('lastSplitTime').textContent = '00:00:00';
    document.getElementById('lastSplitPace').textContent = '0:00/km';
    // Aggiorna badge stato e GPS
    this.updateStatusBadge('ready');
    this.updateGPSIndicator(false);
    this.updateAccuracyIndicator(0); // Resetta accuratezza
    this.updateBatteryStatus(); // Aggiorna stato batteria
    
    // Opzionale: Resetta la mappa
    if (this.miniMap) { 
      this.polyline.setLatLngs([]); // Rimuove il percorso tracciato
      // Potresti anche reimpostare la vista o rimuovere il marker se preferisci
    }
  }
}

// =============================================
// APP TOUR SYSTEM (Tour Guidato per l'Utente)
// =============================================
class AppTour {
  constructor() {
    // Definisce i passi del tour, associando elementi HTML a messaggi
    this.steps = [
      { element: '#routeSelect', title: 'üéØ Percorsi', content: 'Seleziona un percorso predefinito o usa la modalit√† libera.' },
      { element: '#btnStart', title: '‚ñ∂Ô∏è Inizia', content: 'Tocca qui per attivare il GPS e avviare il tracciamento.' },
      { element: '#liveStats', title: 'üìä Statistiche', content: 'Visualizza tempo, distanza, ritmo e velocit√† in tempo reale.' },
      { element: '#miniMap', title: 'üó∫Ô∏è Mappa', content: 'Segui il tuo percorso in diretta sulla mappa.' }
    ];
    this.currentStep = 0; // Indice del passo corrente
  }

  // Avvia il tour se non √® gi√† stato completato
  start() {
    if (localStorage.getItem('appTourCompleted')) return; // Esce se gi√† completato
    this.currentStep = 0; // Inizia dal primo passo
    // Ritardo per assicurarsi che la UI sia caricata prima di mostrare il primo step
    setTimeout(() => this.showStep(this.currentStep), 500); 
  }

  // Mostra il passo corrente del tour
  showStep(index) {
    // Se tutti i passi sono stati mostrati, termina il tour
    if (index >= this.steps.length) { 
      this.removeOverlay(); // Rimuove l'overlay
      localStorage.setItem('appTourCompleted', 'true'); // Segna il tour come completato
      return; 
    }
    this.currentStep = index; // Aggiorna l'indice corrente
    const step = this.steps[index]; // Ottiene i dati del passo corrente
    const targetElement = document.querySelector(step.element); // Trova l'elemento HTML da evidenziare
    
    // Se l'elemento non viene trovato, passa al passo successivo
    if (!targetElement) { 
      this.showStep(index + 1); 
      return; 
    }
    // Crea e mostra l'overlay per il passo corrente
    this.createStepOverlay(step, index);
  }

  // Crea l'elemento overlay e il contenuto del passo corrente
  createStepOverlay(step, index) {
    this.removeOverlay(); // Rimuove eventuali overlay precedenti
    const overlay = document.createElement('div');
    overlay.id = 'tourOverlay'; overlay.className = 'tour-overlay';
    // HTML per il popup del tour
    overlay.innerHTML = `
      <div class="tour-step">
        <div class="tour-content card shadow-lg">
          <div class="card-body text-center">
            <h5 class="tour-title">${step.title}</h5>
            <p class="tour-text">${step.content}</p>
            <div class="tour-footer">
              <small class="tour-counter">${index + 1}/${this.steps.length}</small>
              <div class="d-flex">
                <button class="btn btn-sm btn-outline-secondary tour-skip me-2">Salta</button>
                <button class="btn btn-sm btn-primary tour-next">${index === this.steps.length - 1 ? 'Fine' : 'Avanti'}</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay); // Aggiunge l'overlay al body
    this.highlightElement(document.querySelector(step.element)); // Evidenzia l'elemento target
    // Aggiunge listener per i pulsanti "Avanti" e "Salta"
    overlay.querySelector('.tour-next').addEventListener('click', () => this.next());
    overlay.querySelector('.tour-skip').addEventListener('click', () => this.skip());
    // Chiude il tour se si clicca fuori dal popup
    overlay.addEventListener('click', (e) => { if (e.target === overlay) this.skip(); });
  }

  // Applica stili per evidenziare l'elemento target
  highlightElement(element) {
    if (!element) return;
    element.style.transition = 'box-shadow 0.3s ease, transform 0.3s ease'; // Transizioni fluide
    element.style.boxShadow = '0 0 0 4px rgba(50, 150, 255, 0.7)'; // Ombra blu
    element.style.zIndex = '10002'; // Assicura che sia sopra l'overlay
    element.style.transform = 'scale(1.02)'; // Leggero zoom per farlo risaltare
  }

  // Rimuove l'evidenziazione da tutti gli elementi del tour
  removeHighlight() {
    this.steps.forEach(step => {
      const el = document.querySelector(step.element);
      if (el) { 
        el.style.boxShadow = ''; 
        el.style.zIndex = ''; 
        el.style.transform = ''; 
      }
    });
  }

  // Rimuove l'overlay del tour
  removeOverlay() { 
    this.removeHighlight(); // Prima rimuove l'evidenziazione
    const overlay = document.getElementById('tourOverlay'); 
    if (overlay) overlay.remove(); // Poi rimuove l'elemento overlay
  }
  
  next() { this.showStep(this.currentStep + 1); } // Va al passo successivo
  skip() { this.removeOverlay(); localStorage.setItem('appTourCompleted', 'true'); } // Salta il tour e segna come completato
}

// =============================================
// GESTIONE IMPOSTAZIONI UTENTE
// =============================================
// Carica le impostazioni salvate in localStorage e le applica all'interfaccia
function loadSettings() {
  const settings = JSON.parse(localStorage.getItem('appSettings') || '{}'); // Carica settings o oggetto vuoto
  
  // Imposta valori per i controlli UI
  document.getElementById('themeColor').value = settings.themeColor || 'default';
  document.getElementById('unitSystem').value = settings.unitSystem || 'metric';
  document.getElementById('userWeight').value = settings.userWeight || 70;
  document.getElementById('audioToggle').checked = settings.audioEnabled !== false; // Valore booleano
  document.getElementById('notificationsToggle').checked = settings.notificationsEnabled || false;
  document.getElementById('privacyMode').checked = settings.privacyMode || false;
  
  // Gestione Dark Mode Toggle
  const darkModeEnabled = settings.darkModeEnabled === true; // Assicura che sia true/false
  document.getElementById('darkModeToggle').querySelector('.dark-icon').classList.toggle('d-none', !darkModeEnabled);
  document.getElementById('darkModeToggle').querySelector('.light-icon').classList.toggle('d-none', darkModeEnabled);
  document.body.classList.toggle('dark-mode', darkModeEnabled);
  
  applySettings(settings); // Applica le impostazioni visive (colori)
}

// Salva le impostazioni correnti selezionate dall'utente in localStorage
function saveSettings() {
  const settings = {
    themeColor: document.getElementById('themeColor').value,
    unitSystem: document.getElementById('unitSystem').value,
    userWeight: parseInt(document.getElementById('userWeight').value) || 70,
    audioEnabled: document.getElementById('audioToggle').checked,
    notificationsEnabled: document.getElementById('notificationsToggle').checked,
    privacyMode: document.getElementById('privacyMode').checked,
    darkModeEnabled: document.body.classList.contains('dark-mode') // Salva stato dark mode
  };
  localStorage.setItem('appSettings', JSON.stringify(settings)); // Salva in localStorage
  applySettings(settings); // Ricarica impostazioni visive
  if (window.tracker) window.tracker.loadUserSettings(); // Aggiorna il tracker se esiste
  
  // Chiude il modal delle impostazioni
  const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
  if (modal) modal.hide();
  
  showTempAlert('Impostazioni salvate!', 'success'); // Mostra notifica di successo
}

// Applica le impostazioni visive (tema colore) al body
function applySettings(settings) {
  // Rimuove classi tema precedenti
  document.body.className = document.body.className.replace(/\btheme-\w+/g, ''); 
  // Aggiunge la classe del nuovo tema
  document.body.classList.add(`theme-${settings.themeColor || 'default'}`); 
}

// Mostra un alert temporaneo in alto allo schermo
function showTempAlert(message, type) {
  const alert = document.createElement('div');
  // Classi per stile e posizione fissa
  alert.className = `alert alert-${type} alert-dismissible fade show position-fixed top-2 start-50 translate-middle-x w-75 w-md-auto shadow-lg`;
  alert.style.zIndex = '1051'; // Sopra i modali
  // Contenuto con messaggio e pulsante chiudi
  alert.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert"></button>`;
  document.body.appendChild(alert); // Aggiunge l'alert alla pagina
  // Rimuove l'alert dopo 3 secondi
  setTimeout(() => { if (alert.parentElement) alert.remove(); }, 3000); 
}

// =============================================
// INIZIALIZZAZIONE APP - AL CARICAMENTO DOM
// =============================================
let tracker; // Variabile globale per l'istanza di ActivityTracker

document.addEventListener('DOMContentLoaded', () => {
  // Nasconde la splash screen dopo un breve ritardo
  setTimeout(() => {
    const splash = document.getElementById('welcomeSplash');
    if (splash) {
      splash.style.opacity = '0'; // Dissolvenza
      setTimeout(() => splash.remove(), 500); // Rimuove l'elemento dopo la dissolvenza
    }
  }, 1200);

  tracker = new ActivityTracker(); // Crea istanza del tracker
  loadSettings(); // Carica impostazioni utente

  // Setup del pulsante Dark Mode Toggle
  const darkModeToggle = document.getElementById('darkModeToggle');
  darkModeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode'); // Alterna classe dark-mode
    const lightIcon = darkModeToggle.querySelector('.light-icon');
    const darkIcon = darkModeToggle.querySelector('.dark-icon');
    // Alterna visibilit√† icone luna/sole
    darkIcon.classList.toggle('d-none'); 
    lightIcon.classList.toggle('d-none');
    // Salva la preferenza dark mode in localStorage
    localStorage.setItem('darkModeEnabled', document.body.classList.contains('dark-mode'));
  });

  // Event Listeners per i pulsanti principali del tracking
  document.getElementById('btnStart').addEventListener('click', () => tracker.startTracking());
  document.getElementById('btnPause').addEventListener('click', () => tracker.pauseTracking());
  document.getElementById('btnStop').addEventListener('click', () => tracker.stopTracking());
  
  // Event Listener per salvare le impostazioni dal modal
  document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
  
  // Aggiorna lo stato della batteria ogni minuto
  tracker.updateBatteryStatus(); // Aggiornamento iniziale
  setInterval(tracker.updateBatteryStatus.bind(tracker), 60000); // Aggiornamenti periodici
  
  // Avvia il tour guidato solo se non √® stato completato
  if (!localStorage.getItem('appTourCompleted')) {
     const tour = new AppTour();
     tour.start();
  }

  // Gestione dell'uscita accidentale dalla pagina durante il tracciamento
  window.addEventListener('beforeunload', (e) => {
    // Se il tracciamento √® attivo e non in pausa, mostra un messaggio di conferma
    if (tracker.isTracking && !tracker.isPaused) {
      e.preventDefault(); // Necessario per alcuni browser
      e.returnValue = 'Tracciamento in corso. Uscire?'; // Messaggio mostrato all'utente
    }
  });

  // Recupero sessione di tracciamento interrotta da localStorage
  const backup = localStorage.getItem('activityBackup');
  if (backup) { // Se esiste un backup
    try {
      const backupData = JSON.parse(backup); // Parsa i dati del backup
      // Crea e mostra il modal di recupero sessione
      const modalHtml = `
        <div class="modal fade" id="recoveryModal" tabindex="-1" aria-labelledby="recoveryModalLabel" aria-hidden="true">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content rounded-4 shadow">
              <div class="modal-header bg-warning rounded-top-4">
                <h5 class="modal-title" id="recoveryModalLabel">üìã Sessione Interrotta</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Chiudi"></button>
              </div>
              <div class="modal-body">
                <p>Abbiamo trovato una sessione di tracciamento non salvata:</p>
                <ul class="small">
                  <li>Durata: ${tracker.formatTime(backupData.duration, true)}</li>
                  <li>Distanza: ${backupData.distance?.toFixed(2) || '0.00'} km</li>
                  <li>Iniziata: ${new Date(backupData.startTime).toLocaleString()}</li>
                </ul>
                <p>Vuoi continuare da qui?</p>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary rounded-pill" data-bs-dismiss="modal" onclick="localStorage.removeItem('activityBackup')">Scarta</button>
                <button type="button" class="btn btn-primary rounded-pill" data-bs-dismiss="modal" onclick="window.recoverSession && window.recoverSession()">Riprendi Attivit√†</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.body.insertAdjacentHTML('beforeend', modalHtml); // Aggiunge il modal HTML
      new bootstrap.Modal(document.getElementById('recoveryModal')).show(); // Mostra il modal
      
      // Funzione globale per gestire il recupero della sessione
      window.recoverSession = () => {
        localStorage.removeItem('activityBackup'); // Rimuove il backup dopo averlo gestito
        showTempAlert('Sessione recuperata. Premi "RIPRENDI" o "INIZIA" per continuare.', 'info');
        // Nota: Il ripristino completo dei dati nel tracker richiederebbe logica aggiuntiva qui.
        // Per ora, l'utente viene informato e pu√≤ riprendere o iniziare una nuova attivit√†.
      };
    } catch (error) { 
      console.error('Errore recupero sessione:', error); 
      localStorage.removeItem('activityBackup'); // Rimuove backup corrotto
    }
  }
});
</script>
{% endblock %}